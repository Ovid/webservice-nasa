package WebService::NASA;

# ABSTRACT: Perl interface to NASA's public APIs

# see also https://api.nasa.gov/
# Don't forget timeouts
use v5.20.0;
use WebService::NASA::Moose types => [
    qw(
      Bool
      Dict
      HashRef
      InstanceOf
      NonEmptyStr
      Optional
      PositiveInt
      PositiveOrZeroInt
      Undef
    )
];
use WebService::NASA::Schema qw(get_nasa_schema);

use JSONSchema::Validator;
use PerlX::Maybe;
use Sys::SigAction qw(timeout_call);
use Mojo::UserAgent;
use Mojo::URL;
use Cpanel::JSON::XS;
use Type::Params -sigs;

our $VERSION = '0.4';

param [qw/debug raw testing strict/] => (
    isa     => Bool,
    default => 0,
);

param [qw/validate_request validate_response/] => (
    isa     => Bool,
    default => 1,
);

param timeout => (
    isa     => PositiveInt,
    default => 30,
);

param _api_key => (
    isa      => NonEmptyStr,
    lazy     => 1,
    init_arg => 'api_key',
    default  => method() { $ENV{NASA_API_KEY} // 'DEMO_KEY' },
);

field is_timeout => (
    isa     => Bool,
    writer  => '_set_is_timeout',
    default => 0,
);

field _json => (
    isa     => InstanceOf ['Cpanel::JSON::XS'],
    default => method() { Cpanel::JSON::XS->new->utf8->unblessed_bool(1) },
);

field last_request_time => (
    isa     => PositiveOrZeroInt,
    writer  => '_set_last_request_time',
    default => 0,
);

field requests_remaining => (
    isa     => PositiveOrZeroInt | Undef,
    writer  => '_set_requests_remaining',
    default => undef,
);

field response => (
    isa    => InstanceOf ['Mojo::Message::Response'] | Undef,
    writer => '_set_response',
);

field _ua => (
    isa     => InstanceOf ['Mojo::UserAgent'],
    default => method() { Mojo::UserAgent->new },
);

field _nasa_schema => (
    isa     => HashRef,
    default => method() { get_nasa_schema() },
);

field _validator => (
    isa     => InstanceOf ['JSONSchema::Validator::OAS30'],
    default => method() { JSONSchema::Validator->new( schema => $self->_nasa_schema ) },
);

field _base_url => (
    isa     => NonEmptyStr,
    default => method() { $self->_nasa_schema->{servers}[0]{url} },
);

method is_demo() {
    return $self->_api_key eq 'DEMO_KEY';
}

signature_for _get_response => (
    method => 1,
    named  => [
        route => NonEmptyStr,
        query => HashRef [NonEmptyStr],
    ],
    named_to_list => 1,
);

method _get_response( $route, $query ) {
    $query->{api_key} = $self->_api_key;
    my $url = $self->_url( $route, $query );

    my $requests_remaining = $self->requests_remaining;

    # if it's not defined, we haven't made an API call yet
    if ( defined $requests_remaining && !$requests_remaining ) {
        carp("You have no API credits left for $route. See https://api.nasa.gov/ for more information.");
        return;
    }

    if ( $self->validate_request ) {
		my ($result, $errors, $warnings) = $self->_validator->validate_request(
			method       => 'GET',
			openapi_path => $route,
			parameters   => {
                query => $query,
            },
		);
        if ( !$result ) {
            my @errors = '';
            foreach my $error (@$errors) {
                push @errors,
                  "Bad request for route: $url. " . $error->to_string . ': ' . join "\n\t" => @{ $error->context };
            }
            $errors = join "\n" => @errors;
            if ( $self->strict ) {
                croak $errors;
            }
            else {
                carp $errors;
            }
        }
	}
    my $response;
    $self->_set_is_timeout(0);
    if ( timeout_call( $self->timeout, sub { $response = $self->_GET($url) } ) ) {
        $url = $self->_sanitize_url( $query, $route );
        $self->_set_is_timeout(1);
        carp("Request timed out for $url");
        return;
    }
    $self->_set_response($response);

    $url = $self->_sanitize_url( $query, $route );

    my $remaining = $response->headers->header('X-RateLimit-Remaining');
    if ( defined $remaining ) {
        $self->_set_requests_remaining($remaining);
    }
    $self->_set_last_request_time(time);

    $self->_debug( $response->headers->to_string . "\n" );

    my $response_body = $response->body;
    if ( $self->debug ) {
        $self->_debug($response_body);
    }

    my $raw_response = $self->should_decode ? $self->_json->decode($response_body) : $response_body;

    if ( $self->validate_response ) {
        my ( $result, $errors, undef ) = $self->_validator->validate_response(
            method       => 'GET',
            openapi_path => $route,
            status       => $response->code,
            parameters   => {
                body => [ 1, $response->headers->content_type, $response_body ],
            },
        );
        if ( !$result ) {
            my @errors = '';
            foreach my $error (@$errors) {
                push @errors,
                  "Error response for route: $url. " . $error->to_string . ': ' . join "\n\t" => @{ $error->context };
            }
            $errors = join "\n" => @errors;
            if ( $self->strict ) {
                croak $errors;
            }
            else {
                carp $errors;
            }
        }
    }
    return $raw_response;
}

method _sanitize_url( $query, $route ) {

    # immediately replace the api key with stars in the URL in case this
    # shows up in logs
    $query->{api_key} = 'REDACTED';
    return $self->_url( $route, $query );
}

method should_decode() {
    my $response = $self->response or return 0;
    return $response->is_success && $response->body && $response->headers->header('content-type') eq 'application/json';
}

# an easy target to override for testing
method _GET($url) {
    $self->_debug("GET $url\n");
    return $self->_ua->get($url)->res;
}

method _debug($msg) {
    return if !$self->debug;
    say STDERR $msg;
}

method _url( $url, $query ) {
    return Mojo::URL->new( $self->_base_url . $url )->query($query);
}

# Begin generated code here

[% FOR method IN endpoints.keys.sort;
       definition = endpoints.$method;
       params     = definition.parameters;
%]
signature_for [% method %] => (
    method => 1,
    named  => [
        [%-FOREACH param IN params -%]
        [% param.key %] => [% IF param.value.required %]NonEmptyStr[% ELSE %]Optional[NonEmptyStr][% END %],
        [% END -%]
        api_key => Optional[NonEmptyStr],
    ],
);

method [% method %] ($query) {
    return $self->_get_response( 
        route  => '[% definition.endpoint %]',
        query => {
            [%- FOREACH param IN params -%]
                [% IF !param.value.required %]maybe [% END %][% param.key %] => $query->{[% param.key %]},
            [% END -%]
            maybe api_key => $query->{api_key},
        }
    );
}
[% END %]

__END__

=head1 SYNOPSIS

    use WebService::NASA;

    my $api = WebService::NASA->new(
        api_key => 'your_api_key',
    );

=head1 DESCRIPTION

This project is a Perl client for the NASA API. It is generated from a
full OpenAPI 3.0.0 specification, which can be found at F<nasa/openapi.yaml>.

=head1 METHODS

In addition to the arugments specified below for each method, all methods take
an I<optional> API key. If you do not provide one, the api key supplied in the
contructor will be used. If you did not supply one to the contructor,
C<DEMO_KEY> will be used. Note that the C<DEMO_KEY> is rate limited to 30
requests per ip address per hour and 50 requests per ip address per day.

Passing in an API key is useful if you have multiple keys and want to use a
different one for a specific request.

[% FOR method IN endpoints.keys.sort;
       definition = endpoints.$method;
       params     = definition.parameters;
%]

=head2 C<[% method %]>

    [%- USE PerlTidy; FILTER $PerlTidy %]
    my $result = $nasa->[% method %](
        [%- IF params -%]
          [%- FOREACH param IN params -%]
            [% param.key %] => $[% param.key %],
          [% END -%]
        [%- END -%]
    );
    [%- END -%]

Method for C<[% definition.endpoint %]>.

[% definition.full.description %]

Arguments:

=over 4
[% FOREACH param IN params %]
=item * C<[% param.key %]> 

[% param.value.description %]

[% IF param.value.required %]Required.[% ELSE %]Optional.[% END %]
[% END %]

=back

[% END %]
