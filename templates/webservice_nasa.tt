package WebService::NASA;

# ABSTRACT: Perl interface to NASA's public APIs

# see also https://api.nasa.gov/
# Don't forget timeouts
use v5.20.0;
use WebService::NASA::Moose types => [
    qw(
      Bool
      HashRef
      InstanceOf
      NonEmptyStr
      Optional
      PositiveInt
      PositiveOrZeroInt
      Undef
    )
];
use WebService::NASA::Schema qw(get_nasa_schema);

use JSONSchema::Validator;
use PerlX::Maybe;
use Sys::SigAction qw(timeout_call);
use Mojo::UserAgent;
use Mojo::URL;
use Type::Params -sigs;

our $VERSION = '0.4';

param [qw/debug raw testing strict/] => (
    isa     => Bool,
    default => 0,
);

param [qw/validate_request validate_response/] => (
    isa     => Bool,
    default => 1,
);

param timeout => (
    isa     => PositiveInt,
    default => 30,
);

param _api_key => (
    isa      => NonEmptyStr,
    lazy     => 1,
    init_arg => 'api_key',
    default  => method() { $ENV{NASA_API_KEY} // $self->_api_key // 'DEMO_KEY' },
);

field last_request_time => (
    isa     => PositiveOrZeroInt,
    writer  => '_set_last_request_time',
    default => 0,
);

field requests_remaining => (
    isa     => PositiveOrZeroInt | Undef,
    writer  => '_set_requests_remaining',
    default => undef,
);

field _ua => (
    isa     => InstanceOf ['Mojo::UserAgent'],
    default => method() { Mojo::UserAgent->new },
);

field _nasa_schema => (
    isa     => HashRef,
    default => method() { get_nasa_schema() },
);

field _validator => (
    isa     => InstanceOf ['JSONSchema::Validator::OAS30'],
    default => method() { JSONSchema::Validator->new( schema => $self->_nasa_schema ) },
);

field _base_url => (
    isa     => NonEmptyStr,
    default => method() { $self->_nasa_schema->{servers}[0]{url} },
);

method is_demo() {
    return $self->_api_key eq 'DEMO_KEY';
}

[% FOR method IN endpoints.keys.sort;
       definition = endpoints.$method;
       params     = definition.parameters;
%]
signature_for [% method %] => (
    method => 1,
    [% IF params.size -%]
    named  => [[% FOREACH param IN params %]
        [% param.key %] => [% IF param.value.required %]NonEmptyStr[% ELSE %]Optional[NonEmptyStr][% END %],[% END %]
    ],[% END %]
);

method [% method %] ($arg_for) {
    return $self->_get_response( 
        route  => '[% definition.endpoint %]',
        params => {[% FOREACH param IN params %]
             [% IF !param.value.required %]maybe [% END %][% param.key %] => $arg_for->{[% param.key %]},[% END %]
        }
    );
}
[% END %]

signature_for _get_response => (
    method => 1,
    named  => [
        route  => NonEmptyStr,
        params => HashRef [NonEmptyStr],
    ],
    named_to_list => 1,
);

method _get_response( $route, $params ) {
    $params->{api_key} = $self->_api_key;
    my $url = $self->_url( $route, $params );

    my $requests_remaining = $self->requests_remaining;

    # if it's not defined, we haven't made an API call yet
    if ( defined $requests_remaining && !$requests_remaining ) {
        carp("You have no API credits left for $route. See https://api.nasa.gov/ for more information.");
        return;
    }

    my $response;
    if ( timeout_call( $self->timeout, sub { $response = $self->_GET($url) } ) ) {
        $url = $self->_sanitize_url( $params, $route );
        carp("Request timed out for $url");
        return;
    }

    $url = $self->_sanitize_url( $params, $route );

    my $remaining = $response->headers->header('X-RateLimit-Remaining');
    if ( defined $remaining ) {
        $self->_set_requests_remaining($remaining);
    }
    $self->_set_last_request_time(time);

    $self->_debug( $response->headers->to_string . "\n" );

    my $response_body = $response->body;
    if ( $self->debug ) {
        $self->_debug($response_body);
    }

    my $raw_response
      = $response->is_success
      && $self->should_decode($route)
      && $response_body ? $response->json : $response_body;

    if ( $self->validate_response ) {
        my ( $result, $errors, undef ) = $self->_validator->validate_response(
            method       => 'GET',
            openapi_path => $route,
            status       => $response->code,
            parameters   => {
                body => [ 1, $response->headers->content_type, $response_body ],
            },
        );
        if ( !$result ) {
            my @errors = '';
            foreach my $error (@$errors) {
                push @errors,
                  "Error response for route: $url. " . $error->to_string . ': ' . join "\n\t" => @{ $error->context };
            }
            $errors = join "\n" => @errors;
            if ( $self->strict ) {
                croak $errors;
            }
            else {
                carp $errors;
            }
        }
    }
    return $raw_response;
}

method _sanitize_url( $params, $route ) {

    # immediately replace the api key with stars in the URL in case this
    # shows up in logs
    $params->{api_key} = 'REDACTED';
    return $self->_url( $route, $params );
}

method should_decode($route) {
    return exists $self->_nasa_schema->{paths}{$route}{get}{responses}{200}{content}{'application/json'};
}

# an easy target to override for testing
method _GET($url) {
    $self->_debug("GET $url\n");
    return $self->_ua->get($url)->res;
}

method _debug($msg) {
    return if !$self->debug;
    say STDERR $msg;
}

method _url( $url, $params ) {
    return Mojo::URL->new( $self->_base_url . $url )->query($params);
}

__END__

=head1 SYNOPSIS

    use WebService::NASA;

    my $api = WebService::NASA->new(
        api_key => 'your_api_key',
    );

=head1 METHODS

[% FOR method IN endpoints.keys.sort;
       definition = endpoints.$method;
       params     = definition.parameters;
%]

=head2 C<[% method %]>

    my $result = $nasa->[% method %]([% FOREACH param IN params %]
            [% param.key %] => $[% param.key %],[% END %]
        ],
    );

Method for C<[% definition.endpoint %]>.

[% definition.description %]

Arguments:

=over 4
[% FOREACH param IN params %]
=item * C<[% param.key %]> 

[% param.value.description %]

[% IF param.value.required %]Required.[% ELSE %]Optional.[% END %]
[% END %]
=back

[% END %]
